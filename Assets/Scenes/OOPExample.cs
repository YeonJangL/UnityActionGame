using System.Collections;
using System.Collections.Generic;
using UnityEngine;
#region OOP
// 객체 지향 프로그래밍(OOP)
// 기존 방식 : 프로그램은 명령어들의 집합
// 객체 지향식 설계 : 프로그램은 객체들의 모임

// 클래스 : 객체 지향 프로그램의 기본 구성요소, 사용자 정의 데이터 타입
// -> 변수 & 함수 같이 저장 가능한 자료구조

// 객체 : 클래스가 실제로 메모리 상에 할당된 인스턴스
// 필드 : 클래스 내부에 설계된 변수, 객체의 속성 표현
// 메소드 : 클래스 내부에 설계된 함수, 객체의 기능, 동작 표현

// 객체 지향 설계의 목적(특징)

// 1. 캡슐화 : 클래스 내부의 서로 연관되어있는 속성과 기능을 하나의 캡슐처럼 만들어
// 데이터가 외부로부터 노출되는 것을 방지하는 설계법

// 2. 상속 class 자식 클래스명 : 부모 클래스명의 형태로 설계 함
// 부모 클래스가 가진 모든 변수와 함수를 상속받고 기능 사용 가능
// 상황에 맞게 재정의 하여 새로운 기능으로 만들 수 있음

// 3. 다형성 : 같은 이름의 변수, 함수여도 상황에 따라 다른 의미로 사용될 수 있음.(조건에 따라 다르게 수행)
#endregion

// 자료 구조(Data Structure)
// 효율적인 접근과 수정을 가능하게하는 자료의 조직, 관리, 저장, 데이터 값의 모임, 데이터의 관계 등을 종합해서 일컫는 말

// 자료 구조 유형별 정리
// T : 타입, K : 키 , V : 값
// 명칭                               용도
// LinkedList<T>                 데이터의 등록과 삭제가 빈번하게 발생하는 경우 해당 자료구조 사용
// List<T>                       데이터가 저장된 순서(인덱스)를 빠르게 탐색 가능
// Stack<T>                      데이터를 후입 선출(LIFO) 방식으로 사용할 경우
// Queue<T>                      데이터를 선입 선출(FIFO) 방식으로 사용할 경우
// Dictionary<K, V>              특정 키를 통해 특정 값을 조회하는 경우 사용
// HashSet<T>                    중복되지 않은 데이터를 저장할때 사용(수학적으로 집합의 개념 표현 시에도 사용)
// T[]                           리스트처럼 데이터가 인덱스에 의해 관리되며, 메모리 상에 연속적으로 저장되는 자료구조
//                               고정된 크기를 가지고 있고, 추가 소모되는 메모리 없이 딱 크기에 맞게 제공됨
//                               유니티 에디터 상에선 배열과 리스트는 동일하게 취급되나 스크립트 작업 시에는 배열과 리스트의 사용법이 다르기 때문에 유의해야함

// 자료 구조 별 알고리즘 단계의 수
// 데이터 원소 N개에 대한 알고리즘의 단계 수를 파악하면 해당 자료구조가 빠른지, 느린지 판단 가능
// 위에 적힌 자료 구조 순서대로 시간 복잡도 표현
// O(1) : 데이터의 증가, 감소에 영향을 받지 않고 단계수가 일정하게 유지됨
// O(n) : 그래프로 보면 완벽하게 대각선의 형태로 표현, 데이터 추가당 알고리즘이 1단계씩 증가
//        -> 데이터가 많아질수록 작업 효율 하락
// O(long n) : 아주 조금씩 증가하는 형태의 곡전으로 데이터가 약 두배정도 증가할 때마다 1단계 정도 늘어남

// 효율 분석
// O(1) > O(log n) > 0(N)

// O(1)은 O(log n)과 비교했을때 비등하다. 데이터의 개수가 약 1000개 이상을 넘을 경우O(1)이 효율적임

// 로그(log)는 이렇게 이해해보자
// 2를 몇번 곱해야 N이 나오는가? log2N
// 1이 될때가지 N을 2로 몇번 곱해야하는가? log2N

// 명칭               추가               검색              삭제              인덱스 인한 접근
// LinkedList<T>      O(1)               O(n)              O(n)              O(n)
// List<T>            O(1)               O(n)              O(n)              O(1)
// Stack<T>           O(1)                -                O(1)               -
// Queue<T>           0(1)                -                O(1)               -
// Dictionary<K, V>   O(1)               O(1)              O(1)               -  (인덱스 대신 키를 인덱스 처럼 사용)
// HashSet<T>         O(1)               O(1)              O(1)               -
// T[]                O(n)               O(n)              O(n)              O(1)
// 배열의 경우 추가, 검색, 삭제의 기능이 없기 때문에 따로 로직을 짜 실행해야 함
// 배열은 다 만들어진 고정형 데이터에 대한 불필요한 메모리 낭비를 막기 위해 사용하는 경우가 가장 좋음

public class OOPExample : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
